
// toxivids cheat engine v4 - Console Injectable Version
// Paste this entire script into your browser's developer console to run

(function() {
    
    class ToxividsCheatEngine {
        constructor() {
            this.isVisible = false;
            this.position = { x: 50, y: 50 };
            this.size = { width: 1200, height: 800 };
            this.activeTab = 'memory';
            this.memoryResults = [];
            this.previousScanResults = [];
            this.consoleHistory = [];
            this.frozenVars = new Map();
            this.autoclickerActive = false;
            this.clickInterval = 1000;
            this.clickCount = 0;
            this.clickIntervalId = null;
            this.keybinds = [];
            this.logs = [];
            this.detectionScore = 0;
            this.scanProgress = 0;
            this.isScanning = false;
            this.recordedMacro = [];
            this.isRecording = false;
            this.frozenVarIntervals = new Map();
            this.selectedVariable = null;
            this.selectedElement = null;
            this.deepScanMode = false;
            this.followMouse = false;
            this.keySpammerActive = false;
            this.mousePosition = { x: 0, y: 0 };
            this.eventLogger = [];
            this.networkLogger = [];
            this.originalFunctions = new Map();
            this.explorerState = new Map(); // Track expanded states
            this.monitoringLevel = 'none'; // none, light, medium, deep
            this.monitoringInterval = null;
            this.firstScanDone = false;
            
            this.init();
        }
        
        init() {
            this.createGUI();
            this.bindEvents();
            this.loadSettings();
            this.show();
            this.addLog('info', 'toxivids cheat engine v4 initialized');
            this.logGUIAction('Application started');
        }
        
        createGUI() {
            const existing = document.getElementById('toxivids-cheat-engine');
            if (existing) existing.remove();
            
            this.container = document.createElement('div');
            this.container.id = 'toxivids-cheat-engine';
            this.container.innerHTML = this.getHTML();
            
            const styleElement = document.createElement('style');
            styleElement.textContent = this.getCSS();
            document.head.appendChild(styleElement);
            
            document.body.appendChild(this.container);
            this.bindTabEvents();
            this.bindUIEvents();
        }
        
        getHTML() {
            return `
                <div class="av-window" style="left: ${this.position.x}px; top: ${this.position.y}px; width: ${this.size.width}px; height: ${this.size.height}px;">
                    <div class="av-header">
                        <div class="av-title">üîß toxivids cheat engine v4</div>
                        <div class="av-controls">
                            <button class="av-btn av-minimize">_</button>
                            <button class="av-btn av-close">√ó</button>
                        </div>
                    </div>
                    <div class="av-tabs">
                        <div class="av-tab-list">
                            <button class="av-tab active" data-tab="memory">Memory Scan</button>
                            <button class="av-tab" data-tab="console">Console</button>
                            <button class="av-tab" data-tab="autoclicker">Autoclicker</button>
                            <button class="av-tab" data-tab="explorer">Explorer</button>
                            <button class="av-tab" data-tab="anticheat">Anti-Cheat</button>
                            <button class="av-tab" data-tab="keybinds">Keybinds</button>
                            <button class="av-tab" data-tab="network">Network</button>
                            <button class="av-tab" data-tab="extra">Extra</button>
                            <button class="av-tab" data-tab="logs">Logs</button>
                        </div>
                        <div class="av-tab-content">
                            ${this.getMemoryTabHTML()}
                            ${this.getConsoleTabHTML()}
                            ${this.getAutoclickerTabHTML()}
                            ${this.getExplorerTabHTML()}
                            ${this.getAntiCheatTabHTML()}
                            ${this.getKeybindsTabHTML()}
                            ${this.getNetworkTabHTML()}
                            ${this.getExtraTabHTML()}
                            ${this.getLogsTabHTML()}
                        </div>
                    </div>
                    <div class="av-resize-handle"></div>
                </div>
            `;
        }
        
        getMemoryTabHTML() {
            return `
                <div class="av-tab-pane active" data-tab="memory">
                    <div class="av-toolbar">
                        <input type="text" class="av-input" id="memory-search" placeholder="Search value (e.g., 100, 'text', Game.cookies)..." value="">
                        <select class="av-select" id="memory-type">
                            <option value="all">All Types</option>
                            <option value="number">Number</option>
                            <option value="string">String</option>
                            <option value="boolean">Boolean</option>
                            <option value="object">Object</option>
                            <option value="function">Function</option>
                        </select>
                        <label class="av-checkbox-label">
                            <input type="checkbox" id="deep-scan-mode"> Deep Scan
                        </label>
                        <button class="av-btn av-btn-primary" id="first-scan">üîç First Scan</button>
                        <button class="av-btn" id="next-scan" disabled>üîÑ Next Scan</button>
                        <button class="av-btn" id="clear-results">üóëÔ∏è Clear</button>
                    </div>
                    <div class="av-progress-container">
                        <div class="av-progress" id="scan-progress" style="width: 0%"></div>
                    </div>
                    <div class="av-stats">
                        Results: <span id="result-count">0</span> | 
                        Previous: <span id="previous-count">0</span> |
                        Selected: <span id="selected-count">0</span>
                    </div>
                    <div class="av-memory-container">
                        <div class="av-results" id="memory-results">
                            <div class="av-placeholder">Enter search term and click 'First Scan' to find variables</div>
                        </div>
                        <div class="av-memory-details" id="memory-details">
                            <h4>Memory Details</h4>
                            <div id="memory-info">Select a result to view details</div>
                            <div class="av-selected-list" id="selected-list">
                                <h5>Selected Items (Press Backspace to remove)</h5>
                                <div id="selected-items">No items selected</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getConsoleTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="console">
                    <div class="av-toolbar">
                        <button class="av-btn" id="clear-console">üóëÔ∏è Clear</button>
                        <button class="av-btn" id="save-console">üíæ Save Output</button>
                    </div>
                    <div class="av-console-section">
                        <label>JavaScript Code:</label>
                        <textarea class="av-console-input" id="js-input" placeholder="Type JavaScript code here... (e.g., Game.cookies = 999999)" rows="4"></textarea>
                        <button class="av-btn av-btn-primary" id="execute-js">‚ñ∂ Execute</button>
                    </div>
                    <div class="av-console-section">
                        <label>Console Output:</label>
                        <div class="av-console-output" id="console-output">
                            <div class="av-console-line">toxivids cheat engine v4 Console Ready</div>
                            <div class="av-console-line">Type JavaScript above and click Execute</div>
                        </div>
                    </div>
                    <hr>
                    <div class="av-console-section">
                        <label>Variable Name:</label>
                        <input type="text" class="av-input" id="variable-input" placeholder="Type variable name (e.g., Game.cookies)">
                        <div class="av-variable-controls">
                            <button class="av-btn" id="freeze-value">‚ùÑÔ∏è Freeze Value</button>
                            <button class="av-btn" id="set-infinite">‚ôæÔ∏è Set Infinite</button>
                            <button class="av-btn" id="reset-zero">0Ô∏è‚É£ Reset to 0</button>
                            <button class="av-btn" id="increment-value">‚ûï Increment</button>
                            <button class="av-btn" id="decrement-value">‚ûñ Decrement</button>
                            <button class="av-btn" id="multiply-value">‚úñÔ∏è Multiply x10</button>
                            <button class="av-btn" id="get-value">üëÅÔ∏è Get Value</button>
                            <button class="av-btn" id="unfreeze-all">üîì Unfreeze All</button>
                        </div>
                        <div class="av-status">
                            Frozen variables: <span id="frozen-count">0</span>
                        </div>
                        <div class="av-frozen-list" id="frozen-list">
                            <h5>Frozen Variables (Select and press Backspace to unfreeze)</h5>
                            <div id="frozen-items">No frozen variables</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getAutoclickerTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="autoclicker">
                    <div class="av-section">
                        <h3>üñ±Ô∏è Auto Clicker</h3>
                        <div class="av-form-grid">
                            <div class="av-form-group">
                                <label>Hotkey (single key):</label>
                                <input type="text" class="av-input" id="clicker-hotkey" placeholder="f" maxlength="1">
                            </div>
                            <div class="av-form-group">
                                <label>Target Element:</label>
                                <input type="text" class="av-input" id="click-target" placeholder="#button, .click-me">
                                <button class="av-btn" id="select-element">Select Element</button>
                            </div>
                            <div class="av-form-group">
                                <label>Click Interval (ms):</label>
                                <input type="number" class="av-input" id="click-interval" value="100" min="1" max="10000">
                            </div>
                            <div class="av-form-group">
                                <label>Wait before start (seconds):</label>
                                <input type="number" class="av-input" id="start-delay" value="0" min="0" max="60">
                            </div>
                            <div class="av-form-group">
                                <label>Max Clicks (0 = unlimited):</label>
                                <input type="number" class="av-input" id="max-clicks" value="0" min="0">
                            </div>
                            <div class="av-form-group">
                                <label class="av-checkbox-label">
                                    <input type="checkbox" id="follow-mouse"> Follow Mouse
                                </label>
                            </div>
                        </div>
                        <div class="av-coordinates">
                            <h4>Coordinates</h4>
                            <div class="av-form-grid">
                                <div class="av-form-group">
                                    <label>X:</label>
                                    <input type="number" class="av-input" id="click-x" value="0">
                                </div>
                                <div class="av-form-group">
                                    <label>Y:</label>
                                    <input type="number" class="av-input" id="click-y" value="0">
                                </div>
                                <button class="av-btn" id="get-mouse-pos">Get Mouse Position</button>
                                <button class="av-btn" id="set-coordinates">Set Coordinates</button>
                            </div>
                        </div>
                        <div class="av-controls">
                            <button class="av-btn av-btn-success" id="start-clicker">‚ñ∂ Start</button>
                            <button class="av-btn av-btn-danger" id="stop-clicker">‚èπ Stop</button>
                            <span class="av-status">Status: <span id="clicker-status">Stopped</span></span>
                        </div>
                        <div class="av-stats">
                            <div>Total Clicks: <span id="click-count">0</span></div>
                            <div>Current Position: <span id="current-position">0, 0</span></div>
                            <div>Last Target: <span id="last-target">None</span></div>
                        </div>
                    </div>
                    <div class="av-section">
                        <h3>‚å®Ô∏è Key Spammer</h3>
                        <div class="av-form-grid">
                            <div class="av-form-group">
                                <label>Key to Spam:</label>
                                <input type="text" class="av-input" id="spam-key" placeholder="Enter, Space, a, etc.">
                            </div>
                            <div class="av-form-group">
                                <label>Spam Interval (ms):</label>
                                <input type="number" class="av-input" id="spam-interval" value="100" min="1">
                            </div>
                            <div class="av-form-group">
                                <label>Spam Count (0 = unlimited):</label>
                                <input type="number" class="av-input" id="spam-count" value="0" min="0">
                            </div>
                        </div>
                        <div class="av-controls">
                            <button class="av-btn av-btn-success" id="start-spam">‚ñ∂ Start Spam</button>
                            <button class="av-btn av-btn-danger" id="stop-spam">‚èπ Stop Spam</button>
                            <button class="av-btn" id="send-key">Send Single Key</button>
                            <span class="av-status">Spammed: <span id="spam-counter">0</span></span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getExplorerTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="explorer">
                    <div class="av-explorer-container">
                        <div class="av-explorer-tree" id="explorer-tree">
                            <div class="av-tree-node" data-path="window">
                                <span class="av-tree-toggle">‚ñ∂</span>
                                <span class="av-tree-icon">üåê</span>
                                <span class="av-tree-label">window</span>
                            </div>
                        </div>
                        <div class="av-explorer-panels">
                            <div class="av-explorer-panel">
                                <div class="av-panel-header">
                                    <h4>Variables</h4>
                                    <button class="av-btn" id="load-variables">üì• Load All</button>
                                </div>
                                <div class="av-variable-list" id="variable-list">
                                    <div class="av-placeholder">Select an object to view variables</div>
                                </div>
                            </div>
                            <div class="av-explorer-panel">
                                <div class="av-panel-header">
                                    <h4>Functions</h4>
                                    <button class="av-btn" id="load-functions">üì• Load All</button>
                                </div>
                                <div class="av-function-list" id="function-list">
                                    <div class="av-placeholder">Select an object to view functions</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getAntiCheatTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="anticheat">
                    <div class="av-toolbar">
                        <button class="av-btn av-btn-primary" id="start-anticheat-scan">üîç Start Scan</button>
                        <button class="av-btn" id="quick-scan">‚ö° Quick Scan</button>
                        <button class="av-btn" id="advanced-scan">üéØ Advanced Scan</button>
                        <div class="av-score">
                            Risk Level: <span id="detection-score" class="score-low">0</span>/100
                        </div>
                    </div>
                    <div class="av-scan-progress" id="anticheat-progress" style="display: none;">
                        <div class="av-progress" id="ac-scan-progress"></div>
                        <div id="scan-status">Initializing scan...</div>
                    </div>
                    <div class="av-scan-results" id="anticheat-results">
                        <div class="av-placeholder">Click 'Start Scan' to analyze anti-cheat mechanisms</div>
                    </div>
                </div>
            `;
        }
        
        getKeybindsTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="keybinds">
                    <div class="av-section">
                        <h3>üé• Macro Recorder</h3>
                        <div class="av-controls">
                            <button class="av-btn av-btn-danger" id="start-recording">‚è∫ Start Recording</button>
                            <button class="av-btn" id="stop-recording">‚èπ Stop Recording</button>
                            <button class="av-btn av-btn-success" id="play-macro">‚ñ∂ Play Macro</button>
                            <button class="av-btn" id="save-macro">üíæ Save</button>
                            <button class="av-btn" id="load-macro">üìÅ Load</button>
                            <button class="av-btn" id="clear-macro">üóëÔ∏è Clear</button>
                        </div>
                        <div class="av-status">
                            Status: <span id="recording-status">Ready</span> | 
                            Actions: <span id="macro-count">0</span>
                        </div>
                        <div class="av-macro-list" id="macro-list">
                            <div class="av-placeholder">No recorded actions</div>
                        </div>
                    </div>
                    <div class="av-section">
                        <h3>‚å®Ô∏è Keybind Manager</h3>
                        <div class="av-form-group">
                            <label>Key Combination:</label>
                            <input type="text" class="av-input" id="keybind-key" placeholder="Ctrl+Shift+F1">
                            <label>Action:</label>
                            <select class="av-select" id="keybind-action">
                                <option value="scan">Memory Scan</option>
                                <option value="click">Toggle Autoclicker</option>
                                <option value="freeze">Freeze All Variables</option>
                                <option value="console">Focus Console</option>
                                <option value="hide">Hide/Show GUI</option>
                            </select>
                            <button class="av-btn" id="add-keybind">Add Keybind</button>
                        </div>
                        <div id="keybind-list">
                            <div class="av-placeholder">No keybinds configured</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getNetworkTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="network">
                    <div class="av-toolbar">
                        <button class="av-btn" id="light-monitor">üü¢ Light Scan</button>
                        <button class="av-btn" id="medium-monitor">üü° Medium Scan</button>
                        <button class="av-btn" id="deep-monitor">üî¥ Deep Scan</button>
                        <button class="av-btn" id="stop-monitor">‚èπ Stop Monitor</button>
                        <span class="av-status">Status: <span id="monitor-status">Stopped</span></span>
                    </div>
                    <div class="av-monitor-info">
                        <div class="av-info-card">
                            <h4>Light Scan</h4>
                            <p>Monitors variable changes only</p>
                        </div>
                        <div class="av-info-card">
                            <h4>Medium Scan</h4>
                            <p>Function calls, variable changes, element clicks</p>
                        </div>
                        <div class="av-info-card">
                            <h4>Deep Scan</h4>
                            <p>Logs everything possible (performance impact)</p>
                        </div>
                    </div>
                    <div class="av-network-stats">
                        <div class="av-stat-item">Variables Changed: <span id="var-changes">0</span></div>
                        <div class="av-stat-item">Functions Called: <span id="func-calls">0</span></div>
                        <div class="av-stat-item">Elements Clicked: <span id="elem-clicks">0</span></div>
                        <div class="av-stat-item">Network Requests: <span id="net-requests">0</span></div>
                    </div>
                    <div class="av-monitor-output" id="monitor-output">
                        <div class="av-placeholder">Select a monitoring level to see activity</div>
                    </div>
                </div>
            `;
        }
        
        getExtraTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="extra">
                    <div class="av-section">
                        <h3>üîß Website Manipulation</h3>
                        <div class="av-controls">
                            <button class="av-btn" id="disable-ads">üö´ Block Ads</button>
                            <button class="av-btn" id="enable-copy">üìã Enable Copy/Paste</button>
                            <button class="av-btn" id="remove-overlays">‚ùå Remove Overlays</button>
                            <button class="av-btn" id="show-passwords">üëÅÔ∏è Show Passwords</button>
                            <button class="av-btn" id="disable-redirects">üîó Disable Redirects</button>
                            <button class="av-btn" id="enable-rightclick">üñ±Ô∏è Enable Right Click</button>
                        </div>
                    </div>
                    <div class="av-section">
                        <h3>üéÆ Game Cheats</h3>
                        <div class="av-controls">
                            <button class="av-btn" id="god-mode">üõ°Ô∏è Find God Mode</button>
                            <button class="av-btn" id="speed-hack">‚ö° Speed Multiplier</button>
                            <button class="av-btn" id="unlock-all">üîì Unlock All</button>
                            <button class="av-btn" id="infinite-resources">‚ôæÔ∏è Infinite Resources</button>
                            <button class="av-btn" id="max-level">üìà Max Level</button>
                            <button class="av-btn" id="complete-game">üèÜ Complete Game</button>
                        </div>
                        <div class="av-form-group">
                            <label>Speed Multiplier:</label>
                            <input type="number" class="av-input" id="speed-multiplier" value="2" min="0.1" max="100" step="0.1">
                            <button class="av-btn" id="apply-speed">Apply</button>
                        </div>
                    </div>
                    <div class="av-section">
                        <h3>üé® Visual Enhancements</h3>
                        <div class="av-controls">
                            <button class="av-btn" id="dark-mode">üåô Toggle Dark Mode</button>
                            <button class="av-btn" id="remove-animations">‚è∏Ô∏è Disable Animations</button>
                            <button class="av-btn" id="zoom-in">üîç‚ûï Zoom In</button>
                            <button class="av-btn" id="zoom-out">üîç‚ûñ Zoom Out</button>
                            <button class="av-btn" id="fullscreen">üì∫ Fullscreen</button>
                            <button class="av-btn" id="highlight-clickable">üéØ Highlight Clickable</button>
                        </div>
                    </div>
                    <div class="av-section">
                        <h3>‚ö° Performance</h3>
                        <div class="av-controls">
                            <button class="av-btn" id="boost-performance">üöÄ Boost Performance</button>
                            <button class="av-btn" id="disable-sounds">üîá Disable Sounds</button>
                            <button class="av-btn" id="reduce-quality">üìâ Reduce Quality</button>
                            <button class="av-btn" id="clear-cache">üóëÔ∏è Clear Cache</button>
                            <button class="av-btn" id="stop-all-timers">‚è±Ô∏è Stop All Timers</button>
                            <button class="av-btn" id="pause-game">‚è∏Ô∏è Pause Game</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        getLogsTabHTML() {
            return `
                <div class="av-tab-pane" data-tab="logs">
                    <div class="av-toolbar">
                        <select class="av-select" id="log-filter">
                            <option value="all">All Logs</option>
                            <option value="info">Info</option>
                            <option value="warning">Warning</option>
                            <option value="error">Error</option>
                            <option value="scan">Scan Results</option>
                            <option value="cheat">Cheat Activity</option>
                            <option value="gui">GUI Actions</option>
                        </select>
                        <button class="av-btn" id="clear-logs">üóëÔ∏è Clear</button>
                        <button class="av-btn" id="export-logs">üì• Export</button>
                        <button class="av-btn" id="auto-scroll-logs">üìú Auto Scroll</button>
                    </div>
                    <div class="av-log-stats">
                        Total: <span id="total-logs">0</span> | 
                        Errors: <span id="error-logs">0</span> | 
                        Warnings: <span id="warning-logs">0</span> |
                        GUI Actions: <span id="gui-logs">0</span>
                    </div>
                    <div class="av-log-container" id="log-container">
                        <div class="av-placeholder">No logs yet</div>
                    </div>
                </div>
            `;
        }
        
        getCSS() {
            return `
                #toxivids-cheat-engine {
                    position: fixed;
                    z-index: 999999;
                    font-family: 'Consolas', 'Monaco', monospace;
                    font-size: 12px;
                    color: #fff;
                }
                
                .av-window {
                    position: absolute;
                    background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
                    border: 2px solid #444;
                    border-radius: 8px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
                    min-width: 1000px;
                    min-height: 700px;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                }
                
                .av-header {
                    background: linear-gradient(90deg, #333, #555);
                    color: #fff;
                    padding: 8px 12px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    cursor: move;
                    border-bottom: 1px solid #555;
                }
                
                .av-title {
                    font-weight: bold;
                    font-size: 14px;
                }
                
                .av-controls {
                    display: flex;
                    gap: 4px;
                }
                
                .av-btn {
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    padding: 4px 8px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 11px;
                    transition: all 0.2s;
                    white-space: nowrap;
                }
                
                .av-btn:hover {
                    background: #555;
                    border-color: #777;
                    transform: translateY(-1px);
                }
                
                .av-btn:disabled {
                    background: #333;
                    border-color: #444;
                    color: #666;
                    cursor: not-allowed;
                    transform: none;
                }
                
                .av-btn-primary {
                    background: #0066cc;
                    border-color: #0088ff;
                }
                
                .av-btn-success {
                    background: #00aa00;
                    border-color: #00cc00;
                }
                
                .av-btn-danger {
                    background: #cc0000;
                    border-color: #ff0000;
                }
                
                .av-tabs {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                }
                
                .av-tab-list {
                    display: flex;
                    background: #333;
                    border-bottom: 1px solid #555;
                    overflow-x: auto;
                }
                
                .av-tab {
                    background: #333;
                    color: #ccc;
                    border: none;
                    padding: 8px 12px;
                    cursor: pointer;
                    font-size: 11px;
                    border-right: 1px solid #555;
                    white-space: nowrap;
                    transition: all 0.2s;
                }
                
                .av-tab.active {
                    background: #555;
                    color: #fff;
                }
                
                .av-tab:hover {
                    background: #444;
                }
                
                .av-tab-content {
                    flex: 1;
                    position: relative;
                    overflow: hidden;
                }
                
                .av-tab-pane {
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    padding: 12px;
                    background: #222;
                    color: #fff;
                    display: none;
                    flex-direction: column;
                    overflow-y: auto;
                }
                
                .av-tab-pane.active {
                    display: flex;
                }
                
                .av-toolbar {
                    display: flex;
                    gap: 6px;
                    margin-bottom: 12px;
                    align-items: center;
                    flex-wrap: wrap;
                    padding: 8px;
                    background: #2a2a2a;
                    border-radius: 4px;
                }
                
                .av-input, .av-select, .av-console-input {
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    padding: 6px 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    font-family: inherit;
                }
                
                .av-input:focus, .av-select:focus, .av-console-input:focus {
                    outline: none;
                    border-color: #0088ff;
                    box-shadow: 0 0 5px rgba(0, 136, 255, 0.3);
                }
                
                .av-console-input {
                    width: 100%;
                    resize: vertical;
                    min-height: 60px;
                }
                
                .av-checkbox-label {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    color: #ccc;
                    cursor: pointer;
                }
                
                .av-checkbox-label input[type="checkbox"] {
                    margin: 0;
                }
                
                .av-progress-container {
                    background: #333;
                    height: 6px;
                    border-radius: 3px;
                    margin-bottom: 8px;
                    overflow: hidden;
                }
                
                .av-progress {
                    background: linear-gradient(90deg, #0066cc, #00aaff);
                    height: 100%;
                    transition: width 0.3s;
                    border-radius: 3px;
                }
                
                .av-memory-container {
                    display: flex;
                    gap: 12px;
                    flex: 1;
                }
                
                .av-results {
                    flex: 1;
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    overflow-y: auto;
                    max-height: 400px;
                }
                
                .av-memory-details {
                    width: 350px;
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    overflow-y: auto;
                }
                
                .av-placeholder {
                    color: #888;
                    text-align: center;
                    padding: 20px;
                    font-style: italic;
                }
                
                .av-result-item {
                    background: #2a2a2a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 6px 8px;
                    margin-bottom: 3px;
                    cursor: pointer;
                    transition: all 0.2s;
                    font-size: 10px;
                    line-height: 1.3;
                }
                
                .av-result-item:hover {
                    background: #333;
                    border-color: #666;
                }
                
                .av-result-item.selected {
                    background: #0066cc;
                    border-color: #0088ff;
                }
                
                .av-console-output {
                    background: #000;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    overflow-y: auto;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    max-height: 200px;
                    margin-bottom: 8px;
                }
                
                .av-console-line {
                    margin-bottom: 2px;
                    word-wrap: break-word;
                }
                
                .av-console-section {
                    margin-bottom: 12px;
                }
                
                .av-console-section label {
                    display: block;
                    margin-bottom: 4px;
                    color: #ccc;
                    font-weight: bold;
                }
                
                .av-variable-controls {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 4px;
                    margin-top: 8px;
                }
                
                .av-frozen-list {
                    margin-top: 12px;
                    padding-top: 8px;
                    border-top: 1px solid #444;
                }
                
                .av-section {
                    background: #2a2a2a;
                    border: 1px solid #444;
                    border-radius: 6px;
                    padding: 12px;
                    margin-bottom: 12px;
                }
                
                .av-section h3 {
                    margin: 0 0 12px 0;
                    color: #fff;
                    font-size: 13px;
                    border-bottom: 1px solid #444;
                    padding-bottom: 6px;
                }
                
                .av-form-group {
                    margin-bottom: 8px;
                }
                
                .av-form-group label {
                    display: block;
                    margin-bottom: 4px;
                    color: #ccc;
                    font-size: 11px;
                }
                
                .av-form-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 8px;
                    align-items: end;
                }
                
                .av-coordinates {
                    background: #333;
                    padding: 8px;
                    border-radius: 4px;
                    margin: 8px 0;
                }
                
                .av-controls {
                    display: flex;
                    gap: 6px;
                    align-items: center;
                    margin-bottom: 8px;
                    flex-wrap: wrap;
                }
                
                .av-status {
                    color: #ccc;
                    font-size: 11px;
                }
                
                .av-stats {
                    background: #333;
                    padding: 6px 8px;
                    border-radius: 4px;
                    margin-bottom: 8px;
                    font-size: 11px;
                }
                
                .av-explorer-container {
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                }
                
                .av-explorer-tree {
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    margin-bottom: 12px;
                    max-height: 300px;
                    overflow-y: auto;
                }
                
                .av-tree-node {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    padding: 2px 0;
                    cursor: pointer;
                    font-size: 11px;
                }
                
                .av-tree-node:hover {
                    background: #333;
                }
                
                .av-tree-toggle {
                    width: 12px;
                    text-align: center;
                    user-select: none;
                }
                
                .av-tree-icon {
                    font-size: 12px;
                }
                
                .av-tree-label {
                    flex: 1;
                }
                
                .av-explorer-panels {
                    display: flex;
                    gap: 12px;
                    flex: 1;
                }
                
                .av-explorer-panel {
                    flex: 1;
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    display: flex;
                    flex-direction: column;
                }
                
                .av-panel-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 8px;
                    border-bottom: 1px solid #444;
                    background: #2a2a2a;
                }
                
                .av-variable-list, .av-function-list {
                    flex: 1;
                    padding: 8px;
                    overflow-y: auto;
                    max-height: 300px;
                }
                
                .av-monitor-info {
                    display: flex;
                    gap: 8px;
                    margin-bottom: 12px;
                }
                
                .av-info-card {
                    flex: 1;
                    background: #2a2a2a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    text-align: center;
                }
                
                .av-network-stats {
                    display: flex;
                    gap: 12px;
                    margin-bottom: 12px;
                    flex-wrap: wrap;
                }
                
                .av-stat-item {
                    background: #333;
                    padding: 6px 12px;
                    border-radius: 4px;
                    font-size: 11px;
                }
                
                .av-monitor-output {
                    flex: 1;
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    overflow-y: auto;
                    max-height: 300px;
                    font-family: 'Courier New', monospace;
                    font-size: 10px;
                }
                
                .av-log-container {
                    flex: 1;
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    overflow-y: auto;
                    max-height: 400px;
                }
                
                .av-log-item {
                    background: #2a2a2a;
                    border-left: 3px solid #666;
                    padding: 4px 6px;
                    margin-bottom: 3px;
                    border-radius: 0 4px 4px 0;
                    font-size: 10px;
                    line-height: 1.3;
                }
                
                .av-log-item.info { border-left-color: #0088ff; }
                .av-log-item.warning { border-left-color: #ffaa00; }
                .av-log-item.error { border-left-color: #ff0000; }
                .av-log-item.scan { border-left-color: #00ff00; }
                .av-log-item.cheat { border-left-color: #ff00ff; }
                .av-log-item.gui { border-left-color: #00ffff; }
                
                .av-resize-handle {
                    position: absolute;
                    bottom: 0;
                    right: 0;
                    width: 12px;
                    height: 12px;
                    background: #666;
                    cursor: se-resize;
                }
                
                .score-low { color: #00ff00; }
                .score-medium { color: #ffaa00; }
                .score-high { color: #ff0000; }
                
                .av-macro-list {
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                    max-height: 150px;
                    overflow-y: auto;
                    font-size: 10px;
                }
                
                hr {
                    border: none;
                    border-top: 1px solid #444;
                    margin: 12px 0;
                }
            `;
        }
        
        // Bind Events
        bindEvents() {
            this.bindDragEvents();
            this.bindResizeEvents();
            this.bindWindowEvents();
            this.bindKeyboardEvents();
        }
        
        bindKeyboardEvents() {
            document.addEventListener('keydown', (e) => {
                // Handle hotkeys
                const clickerHotkey = this.container.querySelector('#clicker-hotkey')?.value;
                if (clickerHotkey && e.key.toLowerCase() === clickerHotkey.toLowerCase()) {
                    e.preventDefault();
                    this.toggleAutoclicker();
                    this.logGUIAction('Hotkey pressed: ' + clickerHotkey);
                }
                
                // Handle backspace for removing selected items
                if (e.key === 'Backspace' && this.activeTab === 'memory') {
                    this.removeSelectedMemoryItem();
                }
                
                if (e.key === 'Backspace' && this.activeTab === 'console') {
                    this.removeSelectedFrozenVar();
                }
            });
            
            // Track mouse position
            document.addEventListener('mousemove', (e) => {
                this.mousePosition = { x: e.clientX, y: e.clientY };
                const posElement = this.container.querySelector('#current-position');
                if (posElement) {
                    posElement.textContent = `${e.clientX}, ${e.clientY}`;
                }
            });
        }
        
        bindDragEvents() {
            const header = this.container.querySelector('.av-header');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.av-controls')) return;
                isDragging = true;
                const rect = this.container.querySelector('.av-window').getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
            });
            
            const handleDrag = (e) => {
                if (!isDragging) return;
                this.position.x = e.clientX - dragOffset.x;
                this.position.y = e.clientY - dragOffset.y;
                this.updateWindowPosition();
            };
            
            const stopDrag = () => {
                isDragging = false;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
            };
        }
        
        bindResizeEvents() {
            const handle = this.container.querySelector('.av-resize-handle');
            let isResizing = false;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });
            
            const handleResize = (e) => {
                if (!isResizing) return;
                const rect = this.container.querySelector('.av-window').getBoundingClientRect();
                this.size.width = Math.max(1000, e.clientX - rect.left);
                this.size.height = Math.max(700, e.clientY - rect.top);
                this.updateWindowSize();
            };
            
            const stopResize = () => {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            };
        }
        
        bindWindowEvents() {
            this.container.querySelector('.av-close').addEventListener('click', () => {
                this.logGUIAction('Close button clicked');
                this.hide();
            });
            this.container.querySelector('.av-minimize').addEventListener('click', () => {
                this.logGUIAction('Minimize button clicked');
                this.minimize();
            });
        }
        
        bindTabEvents() {
            const tabs = this.container.querySelectorAll('.av-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    this.logGUIAction('Tab switched to: ' + tab.dataset.tab);
                    this.switchTab(tab.dataset.tab);
                });
            });
        }
        
        bindUIEvents() {
            // Memory Scanner Events
            const firstScanBtn = this.container.querySelector('#first-scan');
            if (firstScanBtn) firstScanBtn.addEventListener('click', () => {
                this.logGUIAction('First scan button clicked');
                this.performFirstScan();
            });
            
            const nextScanBtn = this.container.querySelector('#next-scan');
            if (nextScanBtn) nextScanBtn.addEventListener('click', () => {
                this.logGUIAction('Next scan button clicked');
                this.performNextScan();
            });
            
            const clearResultsBtn = this.container.querySelector('#clear-results');
            if (clearResultsBtn) clearResultsBtn.addEventListener('click', () => {
                this.logGUIAction('Clear results button clicked');
                this.clearMemoryResults();
            });
            
            // Console Events
            const executeBtn = this.container.querySelector('#execute-js');
            if (executeBtn) executeBtn.addEventListener('click', () => {
                this.logGUIAction('Execute JavaScript button clicked');
                this.executeJavaScript();
            });
            
            const clearConsoleBtn = this.container.querySelector('#clear-console');
            if (clearConsoleBtn) clearConsoleBtn.addEventListener('click', () => {
                this.logGUIAction('Clear console button clicked');
                this.clearConsole();
            });
            
            const freezeBtn = this.container.querySelector('#freeze-value');
            if (freezeBtn) freezeBtn.addEventListener('click', () => {
                this.logGUIAction('Freeze value button clicked');
                this.freezeValue();
            });
            
            const setInfiniteBtn = this.container.querySelector('#set-infinite');
            if (setInfiniteBtn) setInfiniteBtn.addEventListener('click', () => {
                this.logGUIAction('Set infinite button clicked');
                this.setInfinite();
            });
            
            const resetZeroBtn = this.container.querySelector('#reset-zero');
            if (resetZeroBtn) resetZeroBtn.addEventListener('click', () => {
                this.logGUIAction('Reset to zero button clicked');
                this.resetToZero();
            });
            
            const incrementBtn = this.container.querySelector('#increment-value');
            if (incrementBtn) incrementBtn.addEventListener('click', () => {
                this.logGUIAction('Increment value button clicked');
                this.incrementValue();
            });
            
            const decrementBtn = this.container.querySelector('#decrement-value');
            if (decrementBtn) decrementBtn.addEventListener('click', () => {
                this.logGUIAction('Decrement value button clicked');
                this.decrementValue();
            });
            
            const multiplyBtn = this.container.querySelector('#multiply-value');
            if (multiplyBtn) multiplyBtn.addEventListener('click', () => {
                this.logGUIAction('Multiply value button clicked');
                this.multiplyValue();
            });
            
            const getValueBtn = this.container.querySelector('#get-value');
            if (getValueBtn) getValueBtn.addEventListener('click', () => {
                this.logGUIAction('Get value button clicked');
                this.getValue();
            });
            
            const unfreezeAllBtn = this.container.querySelector('#unfreeze-all');
            if (unfreezeAllBtn) unfreezeAllBtn.addEventListener('click', () => {
                this.logGUIAction('Unfreeze all button clicked');
                this.unfreezeAllVariables();
            });
            
            // Autoclicker Events
            const startClickerBtn = this.container.querySelector('#start-clicker');
            if (startClickerBtn) startClickerBtn.addEventListener('click', () => {
                this.logGUIAction('Start autoclicker button clicked');
                this.startAutoclicker();
            });
            
            const stopClickerBtn = this.container.querySelector('#stop-clicker');
            if (stopClickerBtn) stopClickerBtn.addEventListener('click', () => {
                this.logGUIAction('Stop autoclicker button clicked');
                this.stopAutoclicker();
            });
            
            const selectElementBtn = this.container.querySelector('#select-element');
            if (selectElementBtn) selectElementBtn.addEventListener('click', () => {
                this.logGUIAction('Select element button clicked');
                this.selectElement();
            });
            
            const getMousePosBtn = this.container.querySelector('#get-mouse-pos');
            if (getMousePosBtn) getMousePosBtn.addEventListener('click', () => {
                this.logGUIAction('Get mouse position button clicked');
                this.getMousePosition();
            });
            
            // Key Spammer Events
            const startSpamBtn = this.container.querySelector('#start-spam');
            if (startSpamBtn) startSpamBtn.addEventListener('click', () => {
                this.logGUIAction('Start key spam button clicked');
                this.startKeySpammer();
            });
            
            const stopSpamBtn = this.container.querySelector('#stop-spam');
            if (stopSpamBtn) stopSpamBtn.addEventListener('click', () => {
                this.logGUIAction('Stop key spam button clicked');
                this.stopKeySpammer();
            });
            
            const sendKeyBtn = this.container.querySelector('#send-key');
            if (sendKeyBtn) sendKeyBtn.addEventListener('click', () => {
                this.logGUIAction('Send single key button clicked');
                this.sendSingleKey();
            });
            
            // Explorer Events
            this.bindExplorerEvents();
            
            // Anti-cheat Events
            const antiCheatScanBtn = this.container.querySelector('#start-anticheat-scan');
            if (antiCheatScanBtn) antiCheatScanBtn.addEventListener('click', () => {
                this.logGUIAction('Anti-cheat scan button clicked');
                this.startAntiCheatScan();
            });
            
            // Macro Events
            const startRecordingBtn = this.container.querySelector('#start-recording');
            if (startRecordingBtn) startRecordingBtn.addEventListener('click', () => {
                this.logGUIAction('Start recording button clicked');
                this.startRecording();
            });
            
            const stopRecordingBtn = this.container.querySelector('#stop-recording');
            if (stopRecordingBtn) stopRecordingBtn.addEventListener('click', () => {
                this.logGUIAction('Stop recording button clicked');
                this.stopRecording();
            });
            
            const playMacroBtn = this.container.querySelector('#play-macro');
            if (playMacroBtn) playMacroBtn.addEventListener('click', () => {
                this.logGUIAction('Play macro button clicked');
                this.playMacro();
            });
            
            const clearMacroBtn = this.container.querySelector('#clear-macro');
            if (clearMacroBtn) clearMacroBtn.addEventListener('click', () => {
                this.logGUIAction('Clear macro button clicked');
                this.clearMacro();
            });
            
            // Network Events
            const lightMonitorBtn = this.container.querySelector('#light-monitor');
            if (lightMonitorBtn) lightMonitorBtn.addEventListener('click', () => {
                this.logGUIAction('Light monitor button clicked');
                this.startLightMonitor();
            });
            
            const mediumMonitorBtn = this.container.querySelector('#medium-monitor');
            if (mediumMonitorBtn) mediumMonitorBtn.addEventListener('click', () => {
                this.logGUIAction('Medium monitor button clicked');
                this.startMediumMonitor();
            });
            
            const deepMonitorBtn = this.container.querySelector('#deep-monitor');
            if (deepMonitorBtn) deepMonitorBtn.addEventListener('click', () => {
                this.logGUIAction('Deep monitor button clicked');
                this.startDeepMonitor();
            });
            
            const stopMonitorBtn = this.container.querySelector('#stop-monitor');
            if (stopMonitorBtn) stopMonitorBtn.addEventListener('click', () => {
                this.logGUIAction('Stop monitor button clicked');
                this.stopMonitoring();
            });
            
            // Extra tab events
            this.bindExtraEvents();
            
            // Log events
            const clearLogsBtn = this.container.querySelector('#clear-logs');
            if (clearLogsBtn) clearLogsBtn.addEventListener('click', () => {
                this.logGUIAction('Clear logs button clicked');
                this.clearLogs();
            });
        }
        
        bindExplorerEvents() {
            const explorerTree = this.container.querySelector('#explorer-tree');
            if (explorerTree) {
                explorerTree.addEventListener('click', (e) => {
                    const node = e.target.closest('.av-tree-node');
                    if (node) {
                        this.logGUIAction('Explorer node clicked: ' + node.dataset.path);
                        this.toggleExplorerNode(node);
                    }
                });
            }
            
            const loadVariablesBtn = this.container.querySelector('#load-variables');
            if (loadVariablesBtn) loadVariablesBtn.addEventListener('click', () => {
                this.logGUIAction('Load variables button clicked');
                this.loadAllVariables();
            });
            
            const loadFunctionsBtn = this.container.querySelector('#load-functions');
            if (loadFunctionsBtn) loadFunctionsBtn.addEventListener('click', () => {
                this.logGUIAction('Load functions button clicked');
                this.loadAllFunctions();
            });
        }
        
        bindExtraEvents() {
            // Website manipulation
            const disableAdsBtn = this.container.querySelector('#disable-ads');
            if (disableAdsBtn) disableAdsBtn.addEventListener('click', () => {
                this.logGUIAction('Disable ads button clicked');
                this.disableAds();
            });
            
            const enableCopyBtn = this.container.querySelector('#enable-copy');
            if (enableCopyBtn) enableCopyBtn.addEventListener('click', () => {
                this.logGUIAction('Enable copy button clicked');
                this.enableCopyPaste();
            });
            
            const removeOverlaysBtn = this.container.querySelector('#remove-overlays');
            if (removeOverlaysBtn) removeOverlaysBtn.addEventListener('click', () => {
                this.logGUIAction('Remove overlays button clicked');
                this.removeOverlays();
            });
            
            const showPasswordsBtn = this.container.querySelector('#show-passwords');
            if (showPasswordsBtn) showPasswordsBtn.addEventListener('click', () => {
                this.logGUIAction('Show passwords button clicked');
                this.showPasswords();
            });
            
            const enableRightClickBtn = this.container.querySelector('#enable-rightclick');
            if (enableRightClickBtn) enableRightClickBtn.addEventListener('click', () => {
                this.logGUIAction('Enable right click button clicked');
                this.enableRightClick();
            });
            
            // Game cheats
            const godModeBtn = this.container.querySelector('#god-mode');
            if (godModeBtn) godModeBtn.addEventListener('click', () => {
                this.logGUIAction('God mode button clicked');
                this.findGodMode();
            });
            
            const speedHackBtn = this.container.querySelector('#speed-hack');
            if (speedHackBtn) speedHackBtn.addEventListener('click', () => {
                this.logGUIAction('Speed hack button clicked');
                this.enableSpeedHack();
            });
            
            const unlockAllBtn = this.container.querySelector('#unlock-all');
            if (unlockAllBtn) unlockAllBtn.addEventListener('click', () => {
                this.logGUIAction('Unlock all button clicked');
                this.unlockAll();
            });
            
            const infiniteResourcesBtn = this.container.querySelector('#infinite-resources');
            if (infiniteResourcesBtn) infiniteResourcesBtn.addEventListener('click', () => {
                this.logGUIAction('Infinite resources button clicked');
                this.infiniteResources();
            });
            
            const maxLevelBtn = this.container.querySelector('#max-level');
            if (maxLevelBtn) maxLevelBtn.addEventListener('click', () => {
                this.logGUIAction('Max level button clicked');
                this.maxLevel();
            });
            
            const completeGameBtn = this.container.querySelector('#complete-game');
            if (completeGameBtn) completeGameBtn.addEventListener('click', () => {
                this.logGUIAction('Complete game button clicked');
                this.completeGame();
            });
            
            // Visual enhancements
            const darkModeBtn = this.container.querySelector('#dark-mode');
            if (darkModeBtn) darkModeBtn.addEventListener('click', () => {
                this.logGUIAction('Dark mode button clicked');
                this.toggleDarkMode();
            });
            
            const removeAnimationsBtn = this.container.querySelector('#remove-animations');
            if (removeAnimationsBtn) removeAnimationsBtn.addEventListener('click', () => {
                this.logGUIAction('Remove animations button clicked');
                this.removeAnimations();
            });
            
            const zoomInBtn = this.container.querySelector('#zoom-in');
            if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
                this.logGUIAction('Zoom in button clicked');
                this.zoomIn();
            });
            
            const zoomOutBtn = this.container.querySelector('#zoom-out');
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
                this.logGUIAction('Zoom out button clicked');
                this.zoomOut();
            });
            
            const fullscreenBtn = this.container.querySelector('#fullscreen');
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', () => {
                this.logGUIAction('Fullscreen button clicked');
                this.toggleFullscreen();
            });
            
            const highlightClickableBtn = this.container.querySelector('#highlight-clickable');
            if (highlightClickableBtn) highlightClickableBtn.addEventListener('click', () => {
                this.logGUIAction('Highlight clickable button clicked');
                this.highlightClickable();
            });
            
            // Performance
            const boostPerformanceBtn = this.container.querySelector('#boost-performance');
            if (boostPerformanceBtn) boostPerformanceBtn.addEventListener('click', () => {
                this.logGUIAction('Boost performance button clicked');
                this.boostPerformance();
            });
            
            const disableSoundsBtn = this.container.querySelector('#disable-sounds');
            if (disableSoundsBtn) disableSoundsBtn.addEventListener('click', () => {
                this.logGUIAction('Disable sounds button clicked');
                this.disableSounds();
            });
            
            const reduceQualityBtn = this.container.querySelector('#reduce-quality');
            if (reduceQualityBtn) reduceQualityBtn.addEventListener('click', () => {
                this.logGUIAction('Reduce quality button clicked');
                this.reduceQuality();
            });
            
            const clearCacheBtn = this.container.querySelector('#clear-cache');
            if (clearCacheBtn) clearCacheBtn.addEventListener('click', () => {
                this.logGUIAction('Clear cache button clicked');
                this.clearCache();
            });
            
            const stopAllTimersBtn = this.container.querySelector('#stop-all-timers');
            if (stopAllTimersBtn) stopAllTimersBtn.addEventListener('click', () => {
                this.logGUIAction('Stop all timers button clicked');
                this.stopAllTimers();
            });
            
            const pauseGameBtn = this.container.querySelector('#pause-game');
            if (pauseGameBtn) pauseGameBtn.addEventListener('click', () => {
                this.logGUIAction('Pause game button clicked');
                this.pauseGame();
            });
        }
        
        // Core GUI Methods
        updateWindowPosition() {
            const windowElement = this.container.querySelector('.av-window');
            windowElement.style.left = this.position.x + 'px';
            windowElement.style.top = this.position.y + 'px';
        }
        
        updateWindowSize() {
            const windowElement = this.container.querySelector('.av-window');
            windowElement.style.width = this.size.width + 'px';
            windowElement.style.height = this.size.height + 'px';
        }
        
        switchTab(tabName) {
            this.container.querySelectorAll('.av-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            this.container.querySelectorAll('.av-tab-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.tab === tabName);
            });
            
            this.activeTab = tabName;
            this.addLog('info', 'Switched to ' + tabName + ' tab');
        }
        
        show() {
            this.container.style.display = 'block';
            this.isVisible = true;
        }
        
        hide() {
            this.container.style.display = 'none';
            this.isVisible = false;
            this.stopAllActivities();
        }
        
        minimize() {
            const windowElement = this.container.querySelector('.av-window');
            windowElement.style.height = '40px';
            this.container.querySelector('.av-tabs').style.display = 'none';
        }
        
        stopAllActivities() {
            this.stopAutoclicker();
            this.stopKeySpammer();
            this.stopMonitoring();
            this.unfreezeAllVariables();
            this.stopRecording();
        }
        
        // Fixed Memory Scanner Methods
        performFirstScan() {
            if (this.isScanning) return;
            
            this.isScanning = true;
            this.scanProgress = 0;
            const searchValue = this.container.querySelector('#memory-search').value.trim();
            const searchType = this.container.querySelector('#memory-type').value;
            this.deepScanMode = this.container.querySelector('#deep-scan-mode').checked;
            
            if (!searchValue) {
                this.addLog('warning', 'Please enter a search value');
                this.isScanning = false;
                return;
            }
            
            this.addLog('info', 'Starting first scan for: ' + searchValue);
            this.updateScanProgress(0);
            
            // Use setTimeout to prevent browser freeze
            setTimeout(() => {
                try {
                    const results = [];
                    this.scanMemoryWithTimeout(results, searchValue, searchType, () => {
                        this.memoryResults = results;
                        this.previousScanResults = [...results]; // Store for next scan
                        this.displayMemoryResults();
                        this.isScanning = false;
                        this.firstScanDone = true;
                        this.updateScanProgress(100);
                        
                        // Enable next scan button
                        const nextScanBtn = this.container.querySelector('#next-scan');
                        if (nextScanBtn) nextScanBtn.disabled = false;
                        
                        this.addLog('scan', 'First scan completed. Found ' + results.length + ' results');
                    });
                } catch (error) {
                    this.addLog('error', 'Scan error: ' + error.message);
                    this.isScanning = false;
                }
            }, 100);
        }
        
        performNextScan() {
            if (this.isScanning || !this.firstScanDone) return;
            
            this.isScanning = true;
            const searchValue = this.container.querySelector('#memory-search').value.trim();
            
            if (!searchValue) {
                this.addLog('warning', 'Please enter a search value');
                this.isScanning = false;
                return;
            }
            
            this.addLog('info', 'Starting next scan for: ' + searchValue);
            this.updateScanProgress(0);
            
            setTimeout(() => {
                try {
                    const results = [];
                    
                    // Only check previous results
                    this.previousScanResults.forEach((result, index) => {
                        try {
                            const currentValue = this.getValueByPath(result.path);
                            if (this.matchesSearchValue(currentValue, searchValue)) {
                                results.push({
                                    ...result,
                                    value: currentValue,
                                    address: this.generateMemoryAddress()
                                });
                            }
                        } catch (e) {
                            // Variable no longer exists
                        }
                        
                        this.updateScanProgress(Math.round((index / this.previousScanResults.length) * 100));
                    });
                    
                    this.memoryResults = results;
                    this.previousScanResults = [...results];
                    this.displayMemoryResults();
                    this.isScanning = false;
                    this.updateScanProgress(100);
                    
                    this.addLog('scan', 'Next scan completed. ' + results.length + ' results remain');
                } catch (error) {
                    this.addLog('error', 'Next scan error: ' + error.message);
                    this.isScanning = false;
                }
            }, 100);
        }
        
        scanMemoryWithTimeout(results, searchValue, searchType, callback) {
            const batchSize = 100;
            let currentIndex = 0;
            const targets = this.getGlobalObjects();
            
            const processBatch = () => {
                const endIndex = Math.min(currentIndex + batchSize, targets.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const obj = targets[i];
                    try {
                        if (this.matchesSearchValue(obj.value, searchValue) && 
                            (searchType === 'all' || typeof obj.value === searchType)) {
                            results.push({
                                path: obj.path,
                                value: obj.value,
                                type: typeof obj.value,
                                address: this.generateMemoryAddress(),
                                writable: this.isWritableByPath(obj.path),
                                size: this.calculateSize(obj.value)
                            });
                        }
                        
                        // Deep scan object properties if enabled
                        if (this.deepScanMode && obj.value && typeof obj.value === 'object') {
                            this.scanObjectProperties(obj.value, obj.path, results, searchValue, searchType, 0);
                        }
                    } catch (e) {
                        // Skip problematic objects
                    }
                }
                
                currentIndex = endIndex;
                this.updateScanProgress(Math.round((currentIndex / targets.length) * 100));
                
                if (currentIndex < targets.length && results.length < 5000) {
                    setTimeout(processBatch, 10); // Continue processing
                } else {
                    callback(); // Done
                }
            };
            
            processBatch();
        }
        
        getGlobalObjects() {
            const objects = [];
            
            // Safely scan window properties
            try {
                const windowKeys = Object.getOwnPropertyNames(window);
                for (const key of windowKeys) {
                    try {
                        const value = window[key];
                        objects.push({ path: key, value: value });
                    } catch (e) {
                        // Skip inaccessible properties
                    }
                }
            } catch (e) {
                // Fallback to for...in loop
                for (const key in window) {
                    try {
                        objects.push({ path: key, value: window[key] });
                    } catch (e) {}
                }
            }
            
            return objects;
        }
        
        matchesSearchValue(value, searchValue) {
            if (searchValue.includes('.')) {
                // Exact path matching handled elsewhere
                return false;
            }
            
            // Numeric matching
            const numericSearch = parseFloat(searchValue);
            if (!isNaN(numericSearch) && value === numericSearch) {
                return true;
            }
            
            // String matching
            const stringValue = String(value).toLowerCase();
            const search = searchValue.toLowerCase();
            
            return stringValue.includes(search);
        }
        
        scanObjectProperties(obj, basePath, results, searchValue, searchType, depth) {
            if (depth > 3 || results.length > 5000) return; // Prevent crashes
            
            try {
                const keys = Object.getOwnPropertyNames(obj);
                for (const key of keys) {
                    try {
                        const value = obj[key];
                        const path = basePath + '.' + key;
                        
                        if (this.matchesSearchValue(value, searchValue) && 
                            (searchType === 'all' || typeof value === searchType)) {
                            results.push({
                                path: path,
                                value: value,
                                type: typeof value,
                                address: this.generateMemoryAddress(),
                                writable: this.isWritable(obj, key),
                                size: this.calculateSize(value)
                            });
                        }
                        
                        if (value && typeof value === 'object' && value !== obj && depth < 2) {
                            this.scanObjectProperties(value, path, results, searchValue, searchType, depth + 1);
                        }
                    } catch (e) {
                        // Skip problematic properties
                    }
                }
            } catch (e) {
                // Skip problematic objects
            }
        }
        
        // ... keep existing code (helper methods like generateMemoryAddress, calculateSize, etc.)
        
        generateMemoryAddress() {
            return '0x' + Math.random().toString(16).substr(2, 8).toUpperCase();
        }
        
        calculateSize(value) {
            if (typeof value === 'string') return value.length + ' chars';
            if (typeof value === 'number') return '8 bytes';
            if (typeof value === 'boolean') return '1 byte';
            if (Array.isArray(value)) return value.length + ' items';
            if (typeof value === 'object' && value !== null) return Object.keys(value).length + ' props';
            return 'unknown';
        }
        
        isWritableByPath(path) {
            try {
                const parts = path.split('.');
                const prop = parts.pop();
                const obj = parts.reduce((o, p) => o[p], window);
                return this.isWritable(obj, prop);
            } catch {
                return false;
            }
        }
        
        isWritable(obj, key) {
            try {
                const descriptor = Object.getOwnPropertyDescriptor(obj, key);
                return !descriptor || descriptor.writable !== false;
            } catch {
                return true;
            }
        }
        
        getValueByPath(path) {
            return path.split('.').reduce((obj, prop) => {
                return obj && obj[prop] !== undefined ? obj[prop] : undefined;
            }, window);
        }
        
        displayMemoryResults() {
            const container = this.container.querySelector('#memory-results');
            const countElement = this.container.querySelector('#result-count');
            const previousElement = this.container.querySelector('#previous-count');
            
            if (countElement) countElement.textContent = this.memoryResults.length;
            if (previousElement) previousElement.textContent = this.previousScanResults.length;
            
            if (this.memoryResults.length === 0) {
                container.innerHTML = '<div class="av-placeholder">No results found. Try a different search term.</div>';
                return;
            }
            
            container.innerHTML = this.memoryResults.slice(0, 1000).map((result, index) => {
                return '<div class="av-result-item" data-index="' + index + '" data-path="' + result.path + '">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                        '<div>' +
                            '<strong>' + result.path + '</strong>' +
                            '<div style="color: #888; font-size: 10px;">' +
                                result.type + ' | ' + (result.writable ? 'RW' : 'RO') + ' | ' + result.size + ' | ' + result.address +
                            '</div>' +
                        '</div>' +
                        '<div style="color: #0088ff; font-family: monospace; font-size: 10px;">' +
                            this.formatValue(result.value) +
                        '</div>' +
                    '</div>' +
                '</div>';
            }).join('');
            
            // Bind click events
            container.querySelectorAll('.av-result-item').forEach(item => {
                item.addEventListener('click', () => {
                    this.selectMemoryItem(item);
                });
                
                item.addEventListener('dblclick', () => {
                    const path = item.dataset.path;
                    this.copyToConsole(path);
                    this.switchTab('console');
                });
            });
        }
        
        selectMemoryItem(item) {
            this.container.querySelectorAll('#memory-results .av-result-item').forEach(i => {
                i.classList.remove('selected');
            });
            item.classList.add('selected');
            
            const index = parseInt(item.dataset.index);
            const result = this.memoryResults[index];
            
            const detailsContainer = this.container.querySelector('#memory-info');
            detailsContainer.innerHTML = `
                <div><strong>Path:</strong> ${result.path}</div>
                <div><strong>Value:</strong> ${this.formatValue(result.value)}</div>
                <div><strong>Type:</strong> ${result.type}</div>
                <div><strong>Address:</strong> ${result.address}</div>
                <div><strong>Size:</strong> ${result.size}</div>
                <div><strong>Writable:</strong> ${result.writable ? 'Yes' : 'No'}</div>
            `;
            
            this.selectedVariable = result.path;
            this.addLog('info', 'Selected memory item: ' + result.path);
        }
        
        removeSelectedMemoryItem() {
            const selectedItem = this.container.querySelector('#memory-results .av-result-item.selected');
            if (selectedItem) {
                const index = parseInt(selectedItem.dataset.index);
                this.memoryResults.splice(index, 1);
                this.displayMemoryResults();
                this.addLog('info', 'Removed selected memory item');
            }
        }
        
        formatValue(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            if (typeof value === 'string') {
                const truncated = value.substring(0, 30);
                return '"' + truncated + (value.length > 30 ? '...' : '') + '"';
            }
            if (typeof value === 'object') {
                if (Array.isArray(value)) return '[Array(' + value.length + ')]';
                return '{Object}';
            }
            if (typeof value === 'function') return 'function()';
            return String(value);
        }
        
        updateScanProgress(percent) {
            const progressBar = this.container.querySelector('#scan-progress');
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
        }
        
        clearMemoryResults() {
            this.memoryResults = [];
            this.previousScanResults = [];
            this.firstScanDone = false;
            this.displayMemoryResults();
            this.container.querySelector('#memory-info').innerHTML = 'Select a result to view details';
            
            // Disable next scan button
            const nextScanBtn = this.container.querySelector('#next-scan');
            if (nextScanBtn) nextScanBtn.disabled = true;
            
            this.addLog('info', 'Memory scan results cleared');
        }
        
        // Enhanced Console Methods
        copyToConsole(path) {
            const input = this.container.querySelector('#variable-input');
            if (input) {
                input.value = path;
                this.selectedVariable = path;
                this.addLog('info', 'Variable ' + path + ' copied to console');
            }
        }
        
        executeJavaScript() {
            const input = this.container.querySelector('#js-input');
            const command = input.value.trim();
            if (!command) return;
            
            const output = this.container.querySelector('#console-output');
            
            this.consoleHistory.push(command);
            
            output.innerHTML += '<div class="av-console-line" style="color: #0088ff;">&gt; ' + command + '</div>';
            
            try {
                const result = window.eval(command);
                output.innerHTML += '<div class="av-console-line" style="color: #00ff00;">' + this.formatConsoleOutput(result) + '</div>';
                this.addLog('cheat', 'Executed: ' + command);
            } catch (error) {
                output.innerHTML += '<div class="av-console-line" style="color: #ff0000;">Error: ' + error.message + '</div>';
                this.addLog('error', 'JavaScript error: ' + error.message);
            }
            
            output.scrollTop = output.scrollHeight;
        }
        
        formatConsoleOutput(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            if (typeof value === 'object') {
                try {
                    return JSON.stringify(value, null, 2);
                } catch {
                    return String(value);
                }
            }
            return String(value);
        }
        
        freezeValue() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) {
                this.addLog('warning', 'Please enter a variable name');
                return;
            }
            
            try {
                const currentValue = this.getValueByPath(varPath);
                if (currentValue === undefined) {
                    this.addLog('error', 'Variable not found: ' + varPath);
                    return;
                }
                
                const intervalId = setInterval(() => {
                    try {
                        this.setValueByPath(varPath, currentValue);
                    } catch (e) {
                        clearInterval(intervalId);
                        this.frozenVars.delete(varPath);
                        this.updateFrozenCount();
                        this.updateFrozenList();
                    }
                }, 100);
                
                this.frozenVars.set(varPath, { intervalId, value: currentValue });
                this.updateFrozenCount();
                this.updateFrozenList();
                
                this.addLog('cheat', 'Frozen ' + varPath + ' at value: ' + currentValue);
            } catch (error) {
                this.addLog('error', 'Failed to freeze variable: ' + error.message);
            }
        }
        
        setValueByPath(path, value) {
            const parts = path.split('.');
            const prop = parts.pop();
            const obj = parts.reduce((o, p) => o[p], window);
            obj[prop] = value;
        }
        
        updateFrozenCount() {
            const countElement = this.container.querySelector('#frozen-count');
            if (countElement) {
                countElement.textContent = this.frozenVars.size;
            }
        }
        
        updateFrozenList() {
            const container = this.container.querySelector('#frozen-items');
            if (!container) return;
            
            if (this.frozenVars.size === 0) {
                container.innerHTML = 'No frozen variables';
                return;
            }
            
            container.innerHTML = Array.from(this.frozenVars.entries()).map(([path, data]) => {
                return '<div class="av-result-item frozen-var-item" data-path="' + path + '">' +
                    '<strong>' + path + '</strong> = ' + this.formatValue(data.value) +
                '</div>';
            }).join('');
            
            // Bind click events for selection
            container.querySelectorAll('.frozen-var-item').forEach(item => {
                item.addEventListener('click', () => {
                    container.querySelectorAll('.frozen-var-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                });
            });
        }
        
        removeSelectedFrozenVar() {
            const selectedItem = this.container.querySelector('#frozen-items .frozen-var-item.selected');
            if (selectedItem) {
                const path = selectedItem.dataset.path;
                const data = this.frozenVars.get(path);
                if (data) {
                    clearInterval(data.intervalId);
                    this.frozenVars.delete(path);
                    this.updateFrozenCount();
                    this.updateFrozenList();
                    this.addLog('info', 'Unfroze variable: ' + path);
                }
            }
        }
        
        setInfinite() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) {
                this.addLog('warning', 'Please enter a variable name');
                return;
            }
            
            try {
                this.setValueByPath(varPath, 1e308);
                this.addLog('cheat', 'Set ' + varPath + ' to infinite');
            } catch (error) {
                this.addLog('error', 'Failed to set infinite: ' + error.message);
            }
        }
        
        resetToZero() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) return;
            
            try {
                this.setValueByPath(varPath, 0);
                this.addLog('cheat', 'Reset ' + varPath + ' to 0');
            } catch (error) {
                this.addLog('error', 'Failed to reset: ' + error.message);
            }
        }
        
        incrementValue() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) return;
            
            try {
                const currentValue = this.getValueByPath(varPath);
                if (typeof currentValue === 'number') {
                    this.setValueByPath(varPath, currentValue + 1);
                    this.addLog('cheat', 'Incremented ' + varPath + ' to ' + (currentValue + 1));
                }
            } catch (error) {
                this.addLog('error', 'Failed to increment: ' + error.message);
            }
        }
        
        decrementValue() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) return;
            
            try {
                const currentValue = this.getValueByPath(varPath);
                if (typeof currentValue === 'number') {
                    this.setValueByPath(varPath, currentValue - 1);
                    this.addLog('cheat', 'Decremented ' + varPath + ' to ' + (currentValue - 1));
                }
            } catch (error) {
                this.addLog('error', 'Failed to decrement: ' + error.message);
            }
        }
        
        multiplyValue() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) return;
            
            try {
                const currentValue = this.getValueByPath(varPath);
                if (typeof currentValue === 'number') {
                    this.setValueByPath(varPath, currentValue * 10);
                    this.addLog('cheat', 'Multiplied ' + varPath + ' by 10 to ' + (currentValue * 10));
                }
            } catch (error) {
                this.addLog('error', 'Failed to multiply: ' + error.message);
            }
        }
        
        getValue() {
            const varPath = this.container.querySelector('#variable-input').value.trim();
            if (!varPath) return;
            
            try {
                const value = this.getValueByPath(varPath);
                const output = this.container.querySelector('#console-output');
                output.innerHTML += '<div class="av-console-line" style="color: #ffaa00;">' + varPath + ' = ' + this.formatConsoleOutput(value) + '</div>';
                output.scrollTop = output.scrollHeight;
                this.addLog('info', 'Retrieved value for ' + varPath);
            } catch (error) {
                this.addLog('error', 'Failed to get value: ' + error.message);
            }
        }
        
        unfreezeAllVariables() {
            this.frozenVars.forEach((data, varName) => {
                clearInterval(data.intervalId);
            });
            this.frozenVars.clear();
            this.updateFrozenCount();
            this.updateFrozenList();
            this.addLog('info', 'All variables unfrozen');
        }
        
        clearConsole() {
            const output = this.container.querySelector('#console-output');
            if (output) {
                output.innerHTML = '<div class="av-console-line">Console cleared</div>';
            }
        }
        
        // Autoclicker Methods (keep existing functionality)
        toggleAutoclicker() {
            if (this.autoclickerActive) {
                this.stopAutoclicker();
            } else {
                this.startAutoclicker();
            }
        }
        
        startAutoclicker() {
            if (this.autoclickerActive) return;
            
            const target = this.container.querySelector('#click-target').value.trim();
            const interval = parseInt(this.container.querySelector('#click-interval').value);
            const maxClicks = parseInt(this.container.querySelector('#max-clicks').value);
            const startDelay = parseInt(this.container.querySelector('#start-delay').value) * 1000;
            const followMouse = this.container.querySelector('#follow-mouse').checked;
            
            this.followMouse = followMouse;
            
            const startClicking = () => {
                this.autoclickerActive = true;
                this.clickCount = 0;
                
                this.clickIntervalId = setInterval(() => {
                    try {
                        let clickX, clickY;
                        
                        if (followMouse) {
                            clickX = this.mousePosition.x;
                            clickY = this.mousePosition.y;
                        } else if (target) {
                            const element = document.querySelector(target);
                            if (element) {
                                const rect = element.getBoundingClientRect();
                                clickX = rect.left + rect.width / 2;
                                clickY = rect.top + rect.height / 2;
                                element.click();
                            } else {
                                clickX = parseInt(this.container.querySelector('#click-x').value);
                                clickY = parseInt(this.container.querySelector('#click-y').value);
                            }
                        } else {
                            clickX = parseInt(this.container.querySelector('#click-x').value);
                            clickY = parseInt(this.container.querySelector('#click-y').value);
                        }
                        
                        this.simulateClick(clickX, clickY);
                        
                        this.clickCount++;
                        this.updateClickCount();
                        
                        if (maxClicks > 0 && this.clickCount >= maxClicks) {
                            this.stopAutoclicker();
                            this.addLog('cheat', 'Autoclicker stopped after ' + maxClicks + ' clicks');
                        }
                    } catch (error) {
                        this.addLog('error', 'Autoclicker error: ' + error.message);
                        this.stopAutoclicker();
                    }
                }, interval);
                
                this.container.querySelector('#clicker-status').textContent = 'Running';
                this.addLog('cheat', 'Autoclicker started' + (target ? ' targeting: ' + target : ''));
            };
            
            if (startDelay > 0) {
                this.addLog('info', 'Autoclicker starting in ' + (startDelay/1000) + ' seconds...');
                setTimeout(startClicking, startDelay);
            } else {
                startClicking();
            }
        }
        
        simulateClick(x, y) {
            const element = document.elementFromPoint(x, y);
            if (element) {
                const event = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                    clientX: x,
                    clientY: y
                });
                element.dispatchEvent(event);
            }
        }
        
        stopAutoclicker() {
            if (this.clickIntervalId) {
                clearInterval(this.clickIntervalId);
                this.clickIntervalId = null;
            }
            
            this.autoclickerActive = false;
            const statusElement = this.container.querySelector('#clicker-status');
            if (statusElement) statusElement.textContent = 'Stopped';
            this.addLog('info', 'Autoclicker stopped');
        }
        
        updateClickCount() {
            const countElement = this.container.querySelector('#click-count');
            if (countElement) {
                countElement.textContent = this.clickCount;
            }
        }
        
        selectElement() {
            this.addLog('info', 'Click on an element to select it as autoclicker target');
            
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const element = e.target;
                let selector = this.generateSelector(element);
                
                this.container.querySelector('#click-target').value = selector;
                this.addLog('info', 'Selected element: ' + selector);
                
                document.removeEventListener('click', handler, true);
            };
            
            document.addEventListener('click', handler, true);
        }
        
        generateSelector(element) {
            if (element.id) return '#' + element.id;
            if (element.className) {
                const classes = element.className.split(' ').filter(c => c && !c.includes(' ')).slice(0, 2);
                if (classes.length > 0) return '.' + classes.join('.');
            }
            return element.tagName.toLowerCase();
        }
        
        getMousePosition() {
            this.container.querySelector('#click-x').value = this.mousePosition.x;
            this.container.querySelector('#click-y').value = this.mousePosition.y;
            this.addLog('info', 'Mouse position captured: ' + this.mousePosition.x + ', ' + this.mousePosition.y);
        }
        
        // Key Spammer Methods
        startKeySpammer() {
            if (this.keySpammerActive) return;
            
            const key = this.container.querySelector('#spam-key').value.trim();
            const interval = parseInt(this.container.querySelector('#spam-interval').value);
            const count = parseInt(this.container.querySelector('#spam-count').value);
            
            if (!key) {
                this.addLog('warning', 'Please enter a key to spam');
                return;
            }
            
            this.keySpammerActive = true;
            let spamCount = 0;
            
            this.keySpamIntervalId = setInterval(() => {
                try {
                    this.sendKeyEvent(key);
                    spamCount++;
                    this.container.querySelector('#spam-counter').textContent = spamCount;
                    
                    if (count > 0 && spamCount >= count) {
                        this.stopKeySpammer();
                        this.addLog('cheat', 'Key spam completed: ' + spamCount + ' keys sent');
                    }
                } catch (error) {
                    this.addLog('error', 'Key spam error: ' + error.message);
                    this.stopKeySpammer();
                }
            }, interval);
            
            this.addLog('cheat', 'Started spamming key: ' + key);
        }
        
        stopKeySpammer() {
            if (this.keySpamIntervalId) {
                clearInterval(this.keySpamIntervalId);
                this.keySpamIntervalId = null;
            }
            this.keySpammerActive = false;
            this.addLog('info', 'Key spammer stopped');
        }
        
        sendSingleKey() {
            const key = this.container.querySelector('#spam-key').value.trim();
            if (key) {
                this.sendKeyEvent(key);
                this.addLog('info', 'Sent key: ' + key);
            }
        }
        
        sendKeyEvent(key) {
            const event = new KeyboardEvent('keydown', {
                key: key,
                code: 'Key' + key.toUpperCase(),
                bubbles: true
            });
            document.dispatchEvent(event);
        }
        
        // Explorer Methods
        toggleExplorerNode(node) {
            const path = node.dataset.path;
            const toggle = node.querySelector('.av-tree-toggle');
            const isExpanded = this.explorerState.get(path) || false;
            
            if (isExpanded) {
                // Collapse
                toggle.textContent = '‚ñ∂';
                this.explorerState.set(path, false);
                this.removeChildNodes(node);
            } else {
                // Expand
                toggle.textContent = '‚ñº';
                this.explorerState.set(path, true);
                this.addChildNodes(node, path);
            }
            
            // Update variable and function lists
            this.updateExplorerPanels(path);
        }
        
        addChildNodes(parentNode, path) {
            try {
                const obj = this.getValueByPath(path);
                if (!obj || typeof obj !== 'object') return;
                
                const keys = Object.getOwnPropertyNames(obj).slice(0, 50); // Limit to prevent crashes
                
                keys.forEach(key => {
                    try {
                        const value = obj[key];
                        const childPath = path + '.' + key;
                        
                        const childNode = document.createElement('div');
                        childNode.className = 'av-tree-node';
                        childNode.dataset.path = childPath;
                        childNode.style.marginLeft = '20px';
                        
                        const hasChildren = value && typeof value === 'object';
                        const icon = typeof value === 'function' ? '‚öôÔ∏è' : 
                                   Array.isArray(value) ? 'üìã' : 
                                   typeof value === 'object' ? 'üìÅ' : 'üìÑ';
                        
                        childNode.innerHTML = `
                            <span class="av-tree-toggle">${hasChildren ? '‚ñ∂' : ' '}</span>
                            <span class="av-tree-icon">${icon}</span>
                            <span class="av-tree-label">${key}</span>
                        `;
                        
                        parentNode.parentNode.insertBefore(childNode, parentNode.nextSibling);
                        
                        if (hasChildren) {
                            childNode.addEventListener('click', (e) => {
                                e.stopPropagation();
                                this.toggleExplorerNode(childNode);
                            });
                        }
                    } catch (e) {
                        // Skip problematic properties
                    }
                });
            } catch (e) {
                this.addLog('error', 'Failed to expand node: ' + e.message);
            }
        }
        
        removeChildNodes(node) {
            let nextNode = node.nextSibling;
            while (nextNode && nextNode.style.marginLeft === '20px') {
                const nodeToRemove = nextNode;
                nextNode = nextNode.nextSibling;
                nodeToRemove.remove();
            }
        }
        
        updateExplorerPanels(path) {
            try {
                const obj = this.getValueByPath(path);
                if (!obj || typeof obj !== 'object') return;
                
                // Update variables panel
                const variableList = this.container.querySelector('#variable-list');
                const functionList = this.container.querySelector('#function-list');
                
                const variables = [];
                const functions = [];
                
                Object.getOwnPropertyNames(obj).slice(0, 100).forEach(key => {
                    try {
                        const value = obj[key];
                        if (typeof value === 'function') {
                            functions.push({ key, value });
                        } else {
                            variables.push({ key, value });
                        }
                    } catch (e) {}
                });
                
                variableList.innerHTML = variables.length > 0 ? 
                    variables.map(v => `
                        <div class="av-result-item" data-var="${path}.${v.key}">
                            <strong>${v.key}</strong>: ${this.formatValue(v.value)}
                        </div>
                    `).join('') : 
                    '<div class="av-placeholder">No variables found</div>';
                
                functionList.innerHTML = functions.length > 0 ?
                    functions.map(f => `
                        <div class="av-result-item" data-func="${path}.${f.key}">
                            <strong>${f.key}()</strong>
                            <div style="color: #888; font-size: 10px;">Function</div>
                        </div>
                    `).join('') :
                    '<div class="av-placeholder">No functions found</div>';
                
                // Bind click events
                variableList.querySelectorAll('.av-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const varPath = item.dataset.var;
                        this.copyToConsole(varPath);
                    });
                });
                
            } catch (e) {
                this.addLog('error', 'Failed to update explorer panels: ' + e.message);
            }
        }
        
        loadAllVariables() {
            this.addLog('info', 'Loading all variables from current scope...');
            // Implementation would scan all variables in the current object
        }
        
        loadAllFunctions() {
            this.addLog('info', 'Loading all functions from current scope...');
            // Implementation would scan all functions in the current object
        }
        
        // Fixed Anti-cheat Scanner
        startAntiCheatScan() {
            if (this.isAntiCheatScanning) return;
            
            this.isAntiCheatScanning = true;
            const progressContainer = this.container.querySelector('#anticheat-progress');
            const progressBar = this.container.querySelector('#ac-scan-progress');
            const statusElement = this.container.querySelector('#scan-status');
            const resultsContainer = this.container.querySelector('#anticheat-results');
            
            if (progressContainer) progressContainer.style.display = 'block';
            if (resultsContainer) resultsContainer.innerHTML = '';
            
            const checks = [
                { name: 'Console Detection', method: this.checkConsoleDetection.bind(this) },
                { name: 'DevTools Detection', method: this.checkDevToolsDetection.bind(this) },
                { name: 'Function Hooks', method: this.checkFunctionHooks.bind(this) },
                { name: 'Variable Protection', method: this.checkVariableProtection.bind(this) },
                { name: 'Network Monitoring', method: this.checkNetworkMonitoring.bind(this) }
            ];
            
            const results = [];
            let riskScore = 0;
            let currentIndex = 0;
            
            const runNextCheck = () => {
                if (currentIndex >= checks.length) {
                    this.detectionScore = Math.min(riskScore, 100);
                    this.displayAntiCheatResults(results);
                    
                    if (progressContainer) progressContainer.style.display = 'none';
                    this.isAntiCheatScanning = false;
                    
                    this.addLog('scan', 'Anti-cheat scan completed. Risk score: ' + this.detectionScore + '/100');
                    return;
                }
                
                const check = checks[currentIndex];
                if (statusElement) statusElement.textContent = 'Running: ' + check.name;
                
                try {
                    const result = check.method();
                    results.push({ name: check.name, ...result });
                    riskScore += result.risk || 0;
                } catch (error) {
                    results.push({ name: check.name, detected: false, risk: 0, error: error.message });
                }
                
                const progress = Math.round(((currentIndex + 1) / checks.length) * 100);
                if (progressBar) progressBar.style.width = progress + '%';
                
                currentIndex++;
                setTimeout(runNextCheck, 300);
            };
            
            runNextCheck();
        }
        
        checkConsoleDetection() {
            let detected = false;
            let risk = 0;
            
            // Check if console methods are overridden
            try {
                if (console.log && console.log.toString().indexOf('native code') === -1) {
                    detected = true;
                    risk = 20;
                }
            } catch (e) {
                detected = true;
                risk = 30;
            }
            
            return {
                detected: detected,
                risk: risk,
                description: detected ? 'Console logging may be monitored' : 'Console appears normal'
            };
        }
        
        checkDevToolsDetection() {
            let detected = false;
            let risk = 0;
            
            // Simple devtools detection
            const start = performance.now();
            console.clear();
            const end = performance.now();
            
            if (end - start > 50) {
                detected = true;
                risk = 25;
            }
            
            return {
                detected: detected,
                risk: risk,
                description: detected ? 'DevTools detection found' : 'No DevTools detection'
            };
        }
        
        checkFunctionHooks() {
            let detected = false;
            let risk = 0;
            
            const functions = ['setTimeout', 'setInterval', 'fetch', 'XMLHttpRequest'];
            let hookedCount = 0;
            
            functions.forEach(funcName => {
                try {
                    const func = window[funcName];
                    if (func && func.toString().indexOf('native code') === -1) {
                        hookedCount++;
                    }
                } catch (e) {
                    hookedCount++;
                }
            });
            
            if (hookedCount > 0) {
                detected = true;
                risk = hookedCount * 10;
            }
            
            return {
                detected: detected,
                risk: risk,
                description: `${hookedCount} functions appear to be hooked`
            };
        }
        
        checkVariableProtection() {
            let detected = false;
            let risk = 0;
            
            // Check common game variables
            const testVars = ['game', 'Game', 'score', 'money', 'coins'];
            let protectedCount = 0;
            
            testVars.forEach(varName => {
                try {
                    if (window[varName] !== undefined) {
                        const descriptor = Object.getOwnPropertyDescriptor(window, varName);
                        if (descriptor && (!descriptor.writable || descriptor.set)) {
                            protectedCount++;
                        }
                    }
                } catch (e) {
                    protectedCount++;
                }
            });
            
            if (protectedCount > 0) {
                detected = true;
                risk = protectedCount * 8;
            }
            
            return {
                detected: detected,
                risk: risk,
                description: `${protectedCount} variables appear to be protected`
            };
        }
        
        checkNetworkMonitoring() {
            let detected = false;
            let risk = 0;
            
            try {
                const xhr = new XMLHttpRequest();
                if (xhr.open.toString().indexOf('native code') === -1) {
                    detected = true;
                    risk = 15;
                }
            } catch (e) {
                detected = true;
                risk = 20;
            }
            
            return {
                detected: detected,
                risk: risk,
                description: detected ? 'Network requests may be monitored' : 'No network monitoring detected'
            };
        }
        
        displayAntiCheatResults(results) {
            const container = this.container.querySelector('#anticheat-results');
            const scoreElement = this.container.querySelector('#detection-score');
            
            if (scoreElement) {
                scoreElement.textContent = this.detectionScore;
                scoreElement.className = this.detectionScore < 30 ? 'score-low' : 
                                       this.detectionScore < 70 ? 'score-medium' : 'score-high';
            }
            
            if (container) {
                container.innerHTML = results.map(result => {
                    return '<div class="av-result-item" style="border-left: 3px solid ' + (result.detected ? '#ff0000' : '#00ff00') + ';">' +
                        '<div style="display: flex; justify-content: space-between;">' +
                            '<strong>' + result.name + '</strong>' +
                            '<span style="color: ' + (result.detected ? '#ff0000' : '#00ff00') + ';">' +
                                (result.detected ? '‚ö†Ô∏è DETECTED' : '‚úÖ CLEAR') +
                            '</span>' +
                        '</div>' +
                        '<div style="color: #ccc; font-size: 11px; margin-top: 4px;">' +
                            (result.description || 'No description') +
                        '</div>' +
                        '<div style="color: #ffaa00; font-size: 10px; text-align: right;">' +
                            'Risk: ' + (result.risk || 0) + '/30' +
                        '</div>' +
                    '</div>';
                }).join('');
            }
        }
        
        // Fixed Macro Recorder
        startRecording() {
            if (this.isRecording) return;
            
            this.isRecording = true;
            this.recordedMacro = [];
            
            const statusElement = this.container.querySelector('#recording-status');
            if (statusElement) statusElement.textContent = 'Recording...';
            
            this.recordMouseEvents();
            this.recordKeyboardEvents();
            
            this.addLog('info', 'Macro recording started');
        }
        
        stopRecording() {
            if (!this.isRecording) return;
            
            this.isRecording = false;
            const statusElement = this.container.querySelector('#recording-status');
            if (statusElement) statusElement.textContent = 'Stopped';
            
            this.removeRecordingListeners();
            this.updateMacroDisplay();
            
            this.addLog('info', 'Macro recording stopped. Recorded ' + this.recordedMacro.length + ' actions');
        }
        
        recordMouseEvents() {
            this.mouseRecordHandler = (e) => {
                if (this.isRecording && !e.target.closest('#toxivids-cheat-engine')) {
                    this.recordedMacro.push({
                        type: 'click',
                        x: e.clientX,
                        y: e.clientY,
                        target: this.generateSelector(e.target),
                        timestamp: Date.now()
                    });
                    this.updateMacroCount();
                }
            };
            
            document.addEventListener('click', this.mouseRecordHandler, true);
        }
        
        recordKeyboardEvents() {
            this.keyRecordHandler = (e) => {
                if (this.isRecording && !e.target.closest('#toxivids-cheat-engine')) {
                    this.recordedMacro.push({
                        type: 'keypress',
                        key: e.key,
                        code: e.code,
                        timestamp: Date.now()
                    });
                    this.updateMacroCount();
                }
            };
            
            document.addEventListener('keydown', this.keyRecordHandler, true);
        }
        
        removeRecordingListeners() {
            if (this.mouseRecordHandler) {
                document.removeEventListener('click', this.mouseRecordHandler, true);
            }
            if (this.keyRecordHandler) {
                document.removeEventListener('keydown', this.keyRecordHandler, true);
            }
        }
        
        updateMacroCount() {
            const countElement = this.container.querySelector('#macro-count');
            if (countElement) {
                countElement.textContent = this.recordedMacro.length;
            }
        }
        
        updateMacroDisplay() {
            const container = this.container.querySelector('#macro-list');
            if (this.recordedMacro.length === 0) {
                container.innerHTML = '<div class="av-placeholder">No recorded actions</div>';
                return;
            }
            
            container.innerHTML = this.recordedMacro.slice(0, 50).map((action, index) => {
                return '<div class="av-result-item" style="font-size: 11px;">' +
                    (index + 1) + '. ' + action.type + ' ' + (action.target || action.key || '') + ' ' +
                    (action.x ? '(' + action.x + ', ' + action.y + ')' : '') +
                '</div>';
            }).join('');
        }
        
        playMacro() {
            if (this.recordedMacro.length === 0) {
                this.addLog('warning', 'No macro recorded');
                return;
            }
            
            this.addLog('info', 'Playing macro with ' + this.recordedMacro.length + ' actions');
            
            let actionIndex = 0;
            const playNextAction = () => {
                if (actionIndex >= this.recordedMacro.length) {
                    this.addLog('info', 'Macro playback completed');
                    return;
                }
                
                const action = this.recordedMacro[actionIndex];
                try {
                    if (action.type === 'click') {
                        const element = document.querySelector(action.target);
                        if (element) {
                            element.click();
                        } else {
                            this.simulateClick(action.x, action.y);
                        }
                    } else if (action.type === 'keypress') {
                        this.sendKeyEvent(action.key);
                    }
                } catch (error) {
                    this.addLog('error', 'Macro playback error: ' + error.message);
                }
                
                actionIndex++;
                setTimeout(playNextAction, 100);
            };
            
            playNextAction();
        }
        
        clearMacro() {
            this.recordedMacro = [];
            this.updateMacroCount();
            this.updateMacroDisplay();
            this.addLog('info', 'Macro cleared');
        }
        
        // Network Monitoring Methods
        startLightMonitor() {
            this.stopMonitoring();
            this.monitoringLevel = 'light';
            this.startVariableMonitoring();
            this.container.querySelector('#monitor-status').textContent = 'Light Monitoring';
            this.addLog('info', 'Light monitoring started - watching variable changes');
        }
        
        startMediumMonitor() {
            this.stopMonitoring();
            this.monitoringLevel = 'medium';
            this.startVariableMonitoring();
            this.startFunctionMonitoring();
            this.startClickMonitoring();
            this.container.querySelector('#monitor-status').textContent = 'Medium Monitoring';
            this.addLog('info', 'Medium monitoring started - watching variables, functions, and clicks');
        }
        
        startDeepMonitor() {
            this.stopMonitoring();
            this.monitoringLevel = 'deep';
            this.startVariableMonitoring();
            this.startFunctionMonitoring();
            this.startClickMonitoring();
            this.startNetworkMonitoring();
            this.startDOMMonitoring();
            this.container.querySelector('#monitor-status').textContent = 'Deep Monitoring';
            this.addLog('info', 'Deep monitoring started - logging everything');
        }
        
        stopMonitoring() {
            this.monitoringLevel = 'none';
            if (this.monitoringInterval) {
                clearInterval(this.monitoringInterval);
                this.monitoringInterval = null;
            }
            this.container.querySelector('#monitor-status').textContent = 'Stopped';
            this.addLog('info', 'Monitoring stopped');
        }
        
        startVariableMonitoring() {
            // Monitor common game variables
            const varsToWatch = ['Game', 'game', 'score', 'money', 'coins', 'health', 'level'];
            varsToWatch.forEach(varName => {
                if (window[varName] !== undefined) {
                    this.watchVariableForMonitoring(varName);
                }
            });
        }
        
        watchVariableForMonitoring(varName) {
            try {
                const originalValue = window[varName];
                let currentValue = originalValue;
                
                Object.defineProperty(window, varName, {
                    get: () => currentValue,
                    set: (newValue) => {
                        this.logMonitorEvent('Variable Changed', `${varName}: ${currentValue} ‚Üí ${newValue}`);
                        this.updateMonitorStats('var-changes');
                        currentValue = newValue;
                    }
                });
            } catch (e) {
                // Variable not writable
            }
        }
        
        startFunctionMonitoring() {
            // Monitor common functions
            const funcsToWatch = ['setTimeout', 'setInterval', 'fetch', 'eval'];
            funcsToWatch.forEach(funcName => {
                this.hookFunctionForMonitoring(funcName);
            });
        }
        
        hookFunctionForMonitoring(funcName) {
            try {
                const original = window[funcName];
                if (original && typeof original === 'function') {
                    window[funcName] = function(...args) {
                        this.logMonitorEvent('Function Called', `${funcName}(${args.length} args)`);
                        this.updateMonitorStats('func-calls');
                        return original.apply(this, args);
                    }.bind(this);
                }
            } catch (e) {
                // Function not hookable
            }
        }
        
        startClickMonitoring() {
            document.addEventListener('click', (e) => {
                if (this.monitoringLevel !== 'none') {
                    this.logMonitorEvent('Element Clicked', `${e.target.tagName}${e.target.id ? '#' + e.target.id : ''}`);
                    this.updateMonitorStats('elem-clicks');
                }
            });
        }
        
        startNetworkMonitoring() {
            // Hook fetch and XMLHttpRequest
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                this.logMonitorEvent('Network Request', `fetch(${args[0]})`);
                this.updateMonitorStats('net-requests');
                return originalFetch.apply(this, args);
            }.bind(this);
        }
        
        startDOMMonitoring() {
            // Monitor DOM changes
            const observer = new MutationObserver((mutations) => {
                if (this.monitoringLevel === 'deep') {
                    mutations.forEach(mutation => {
                        this.logMonitorEvent('DOM Changed', `${mutation.type}: ${mutation.target.tagName}`);
                    });
                }
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true
            });
        }
        
        logMonitorEvent(type, message) {
            const output = this.container.querySelector('#monitor-output');
            if (output) {
                const timestamp = new Date().toLocaleTimeString();
                output.innerHTML += `<div>[${timestamp}] ${type}: ${message}</div>`;
                output.scrollTop = output.scrollHeight;
                
                // Keep only last 100 lines
                const lines = output.children;
                if (lines.length > 100) {
                    output.removeChild(lines[0]);
                }
            }
        }
        
        updateMonitorStats(statType) {
            const element = this.container.querySelector('#' + statType);
            if (element) {
                const current = parseInt(element.textContent) || 0;
                element.textContent = current + 1;
            }
        }
        
        // Extra Tab Functional Methods
        disableAds() {
            const adSelectors = [
                '[id*="ad"]', '[class*="ad"]', '[id*="banner"]', '[class*="banner"]',
                'iframe[src*="ads"]', 'iframe[src*="doubleclick"]', '.advertisement'
            ];
            
            let removedCount = 0;
            adSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(element => {
                    element.style.display = 'none';
                    removedCount++;
                });
            });
            
            this.addLog('cheat', `Disabled ${removedCount} potential ad elements`);
        }
        
        enableCopyPaste() {
            // Remove copy/paste restrictions
            document.addEventListener('contextmenu', e => e.stopPropagation(), true);
            document.addEventListener('selectstart', e => e.stopPropagation(), true);
            document.addEventListener('copy', e => e.stopPropagation(), true);
            document.addEventListener('paste', e => e.stopPropagation(), true);
            
            // Enable text selection
            document.body.style.userSelect = 'text';
            document.body.style.webkitUserSelect = 'text';
            
            this.addLog('cheat', 'Copy/paste enabled');
        }
        
        removeOverlays() {
            // Remove fixed/absolute positioned overlays
            document.querySelectorAll('*').forEach(element => {
                const style = getComputedStyle(element);
                if ((style.position === 'fixed' || style.position === 'absolute') && 
                    (style.zIndex > 1000 || style.background.includes('rgba'))) {
                    element.style.display = 'none';
                }
            });
            
            this.addLog('cheat', 'Removed overlay elements');
        }
        
        showPasswords() {
            let count = 0;
            document.querySelectorAll('input[type="password"]').forEach(input => {
                input.type = 'text';
                count++;
            });
            this.addLog('cheat', `Revealed ${count} password fields`);
        }
        
        enableRightClick() {
            document.addEventListener('contextmenu', e => e.stopPropagation(), true);
            this.addLog('cheat', 'Right click enabled');
        }
        
        findGodMode() {
            const possibleGodModeVars = [
                'invincible', 'godMode', 'immortal', 'invulnerable', 
                'health', 'hp', 'lives', 'damage'
            ];
            
            let found = [];
            possibleGodModeVars.forEach(varName => {
                this.searchForVariable(varName, found);
            });
            
            this.addLog('scan', `Found ${found.length} potential god mode variables: ${found.join(', ')}`);
        }
        
        searchForVariable(varName, results) {
            for (const key in window) {
                if (key.toLowerCase().includes(varName.toLowerCase())) {
                    results.push(key);
                }
            }
        }
        
        enableSpeedHack() {
            const multiplier = parseFloat(this.container.querySelector('#speed-multiplier').value);
            
            // Hook animation functions
            const originalRAF = window.requestAnimationFrame;
            window.requestAnimationFrame = function(callback) {
                return originalRAF(function(time) {
                    callback(time * multiplier);
                });
            };
            
            this.addLog('cheat', `Speed hack enabled with ${multiplier}x multiplier`);
        }
        
        unlockAll() {
            // Look for common unlock variables
            const unlockVars = ['unlocked', 'locked', 'available', 'enabled'];
            unlockVars.forEach(varName => {
                for (const key in window) {
                    if (key.toLowerCase().includes(varName)) {
                        try {
                            if (typeof window[key] === 'boolean') {
                                window[key] = varName === 'locked' ? false : true;
                            }
                        } catch (e) {}
                    }
                }
            });
            
            this.addLog('cheat', 'Attempted to unlock all features');
        }
        
        infiniteResources() {
            const resourceVars = ['money', 'coins', 'gold', 'gems', 'points', 'score'];
            let modified = 0;
            
            resourceVars.forEach(varName => {
                for (const key in window) {
                    if (key.toLowerCase().includes(varName)) {
                        try {
                            if (typeof window[key] === 'number') {
                                window[key] = 999999999;
                                modified++;
                            }
                        } catch (e) {}
                    }
                }
            });
            
            this.addLog('cheat', `Set ${modified} resource variables to infinite`);
        }
        
        maxLevel() {
            const levelVars = ['level', 'lvl', 'rank', 'tier'];
            let modified = 0;
            
            levelVars.forEach(varName => {
                for (const key in window) {
                    if (key.toLowerCase().includes(varName)) {
                        try {
                            if (typeof window[key] === 'number') {
                                window[key] = 9999;
                                modified++;
                            }
                        } catch (e) {}
                    }
                }
            });
            
            this.addLog('cheat', `Set ${modified} level variables to maximum`);
        }
        
        completeGame() {
            // Look for completion variables
            const completionVars = ['complete', 'finished', 'done', 'progress'];
            let modified = 0;
            
            completionVars.forEach(varName => {
                for (const key in window) {
                    if (key.toLowerCase().includes(varName)) {
                        try {
                            if (typeof window[key] === 'boolean') {
                                window[key] = true;
                                modified++;
                            } else if (typeof window[key] === 'number') {
                                window[key] = 100;
                                modified++;
                            }
                        } catch (e) {}
                    }
                }
            });
            
            this.addLog('cheat', `Modified ${modified} completion variables`);
        }
        
        toggleDarkMode() {
            document.body.style.filter = document.body.style.filter ? '' : 'invert(1) hue-rotate(180deg)';
            this.addLog('cheat', 'Dark mode toggled');
        }
        
        removeAnimations() {
            const style = document.createElement('style');
            style.textContent = '*, *::before, *::after { animation: none !important; transition: none !important; }';
            document.head.appendChild(style);
            this.addLog('cheat', 'Animations disabled');
        }
        
        zoomIn() {
            document.body.style.zoom = (parseFloat(document.body.style.zoom) || 1) + 0.1;
            this.addLog('cheat', 'Zoomed in');
        }
        
        zoomOut() {
            document.body.style.zoom = Math.max(0.1, (parseFloat(document.body.style.zoom) || 1) - 0.1);
            this.addLog('cheat', 'Zoomed out');
        }
        
        toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
            this.addLog('cheat', 'Fullscreen toggled');
        }
        
        highlightClickable() {
            const clickableElements = document.querySelectorAll('button, a, input, [onclick], [role="button"]');
            clickableElements.forEach(element => {
                element.style.border = '2px solid red';
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
            });
            this.addLog('cheat', `Highlighted ${clickableElements.length} clickable elements`);
        }
        
        boostPerformance() {
            // Reduce visual effects
            document.body.style.transform = 'translateZ(0)';
            document.body.style.backfaceVisibility = 'hidden';
            
            // Disable smooth scrolling
            document.documentElement.style.scrollBehavior = 'auto';
            
            this.addLog('cheat', 'Performance boost applied');
        }
        
        disableSounds() {
            // Mute all audio elements
            document.querySelectorAll('audio, video').forEach(element => {
                element.muted = true;
                element.volume = 0;
            });
            
            // Override audio context
            if (window.AudioContext) {
                window.AudioContext = function() { return null; };
            }
            
            this.addLog('cheat', 'All sounds disabled');
        }
        
        reduceQuality() {
            // Reduce image quality
            document.querySelectorAll('img').forEach(img => {
                img.style.imageRendering = 'pixelated';
            });
            
            // Reduce canvas quality
            document.querySelectorAll('canvas').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.imageSmoothingEnabled = false;
                }
            });
            
            this.addLog('cheat', 'Visual quality reduced');
        }
        
        clearCache() {
            // Clear various caches
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => caches.delete(name));
                });
            }
            
            // Clear storage
            localStorage.clear();
            sessionStorage.clear();
            
            this.addLog('cheat', 'Cache and storage cleared');
        }
        
        stopAllTimers() {
            // Get all timeout/interval IDs and clear them
            const highestId = setTimeout(() => {}, 0);
            for (let i = 0; i < highestId; i++) {
                clearTimeout(i);
                clearInterval(i);
            }
            this.addLog('cheat', 'All timers stopped');
        }
        
        pauseGame() {
            // Pause common game loops
            window.gameLoop = function() {};
            window.update = function() {};
            window.render = function() {};
            
            this.addLog('cheat', 'Game paused (attempted)');
        }
        
        // Logging methods
        logGUIAction(action) {
            this.addLog('gui', action);
        }
        
        addLog(logType, message) {
            const timestamp = new Date().toLocaleTimeString();
            const log = {
                type: logType,
                message: message,
                timestamp: timestamp,
                id: Date.now() + Math.random()
            };
            
            this.logs.unshift(log);
            
            if (this.logs.length > 2000) {
                this.logs = this.logs.slice(0, 2000);
            }
            
            this.updateLogDisplay();
            this.updateLogStats();
        }
        
        updateLogDisplay() {
            const container = this.container.querySelector('#log-container');
            if (!container) return;
            
            const filter = this.container.querySelector('#log-filter');
            const filterValue = filter ? filter.value : 'all';
            const filteredLogs = filterValue === 'all' ? this.logs : this.logs.filter(log => log.type === filterValue);
            
            if (filteredLogs.length === 0) {
                container.innerHTML = '<div class="av-placeholder">No logs to display</div>';
                return;
            }
            
            container.innerHTML = filteredLogs.slice(0, 1000).map(log => {
                return '<div class="av-log-item ' + log.type + '">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                        '<span><strong>[' + log.type.toUpperCase() + ']</strong> ' + log.message + '</span>' +
                        '<span style="color: #888; font-size: 9px;">' + log.timestamp + '</span>' +
                    '</div>' +
                '</div>';
            }).join('');
        }
        
        updateLogStats() {
            const totalElement = this.container.querySelector('#total-logs');
            const errorElement = this.container.querySelector('#error-logs');
            const warningElement = this.container.querySelector('#warning-logs');
            const guiElement = this.container.querySelector('#gui-logs');
            
            if (totalElement) totalElement.textContent = this.logs.length;
            if (errorElement) errorElement.textContent = this.logs.filter(l => l.type === 'error').length;
            if (warningElement) warningElement.textContent = this.logs.filter(l => l.type === 'warning').length;
            if (guiElement) guiElement.textContent = this.logs.filter(l => l.type === 'gui').length;
        }
        
        clearLogs() {
            this.logs = [];
            this.updateLogDisplay();
            this.updateLogStats();
            this.addLog('info', 'Logs cleared');
        }
        
        filterLogs(filter) {
            this.updateLogDisplay();
        }
        
        exportLogs() {
            const data = {
                exportDate: new Date().toISOString(),
                logs: this.logs,
                stats: {
                    total: this.logs.length,
                    errors: this.logs.filter(l => l.type === 'error').length,
                    warnings: this.logs.filter(l => l.type === 'warning').length,
                    gui: this.logs.filter(l => l.type === 'gui').length
                }
            };
            
            this.downloadJSON(data, 'toxivids-cheat-engine-logs-' + Date.now() + '.json');
            this.addLog('info', 'Logs exported to file');
        }
        
        // Utility methods
        downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        loadSettings() {
            try {
                const settings = localStorage.getItem('toxivids-cheat-engine-settings');
                if (settings) {
                    const parsed = JSON.parse(settings);
                    this.position = parsed.position || this.position;
                    this.size = parsed.size || this.size;
                }
            } catch (e) {
                this.addLog('warning', 'Failed to load settings');
            }
        }
        
        saveSettings() {
            try {
                const settings = {
                    position: this.position,
                    size: this.size,
                    logs: this.logs.slice(0, 100)
                };
                localStorage.setItem('toxivids-cheat-engine-settings', JSON.stringify(settings));
            } catch (e) {
                this.addLog('warning', 'Failed to save settings');
            }
        }
        
        destroy() {
            this.stopAllActivities();
            this.saveSettings();
            if (this.container) {
                this.container.remove();
            }
        }
    }
    
    // Create global instance
    if (window.toxividsCheatEngine) {
        window.toxividsCheatEngine.destroy();
    }
    
    window.toxividsCheatEngine = new ToxividsCheatEngine();
    
    console.log('%cüîß toxivids cheat engine v4 Loaded!', 'color: #00ff00; font-size: 16px; font-weight: bold;');
    console.log('%cUse window.toxividsCheatEngine to access the instance', 'color: #0088ff;');
    console.log('%cGUI should be visible on your screen. Drag to move, resize from bottom-right corner.', 'color: #ffaa00;');
    console.log('%cPress hotkeys to control autoclicker, backspace to remove selected items', 'color: #ffaa00;');
    
})();

// End of toxivids cheat engine v4
